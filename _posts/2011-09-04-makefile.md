---
author: manuzhang
comments: true
date: 2011-09-04 01:15:35+00:00
layout: post
published: false
slug: makefile
title: Makefile
wordpress_id: 36
categories:
- linux
tags:
- makefile
---

For long we have been using the command _make_ and _make install_ to install applications from source packages in Linux.

Also, the OpenGL tutorials use Makefile to compile its .cpp source codes, from which I've learned the Makefile is nothing special but the _cc_ commands and options put into a file.

Well, of course it is far more than that.

Fortunately, I came across an article on make and Makefile in _LinuxJournal_.

Now, it's time to look back. All the terminologies are from the article.

I'll illustrate it in the form of comments, which is led by pound(#) in Makefile.



<!-- more -->

The first sample is from the OpenGL tutorial.



**`</p>
<h1>variables as in any other programming languages</h1>
<h1>they will be used in the rules</h1>
<p>CC = g++       # g++ compiler for .cpp<br />
CFLAGS = -Wall # compiling flags: warning all<br />
PROG = basics<br />
SRCS = basics.c`**





# directives



ifeq ($(shell uname),Darwin)





# if I run uname in my shell I will get Linux





# Darwin is for OS X, I guess



LIBS = -framework OpenGL -framework GLUT

else

LIBS = -lGL -lGLU -lglut        





# thus, these libs will be used





# otherwise, the OpenGL codes won't work



endif





# phony targets, "phony" means not genuine





# they are aliases here. Remember make install and make clean.





# install and clean are aliases.





# all is the default alias





# so make is identical to make all.



all: $(PROG)





# rule





# the format of a rule is





# target:dependency lists





# commands





# commands must be led by a tab



$(PROG):$(SRCS)

$(CC) $(CFLAGS) -o $(PROG) $(SRCS) $(LIBS)

clean:

rm -f $(PROG)



Now, you see how it works out. Another example is from the author.

I will only highlight new concepts.



**`<br />
CC = g++</p>
<h1>-c means do not link</h1>
<p>CFLAGS = -c -Wall</p>
<h1>linking flags</h1>
<p>LDFLAGS =<br />
SOURCES = main.cpp hello.cpp factorial.cpp</p>
<h1>assign SOURCES to OBJECTS but replace all .cpp suffixes with .o</h1>
<p>OBJECTS = $(SOURCES: .cpp = .o)<br />
EXECUTABLE = hello`**



all: $(SOURCES) $(EXECUTABLE)

$(EXECUTABLE): $(OBJECTS)





# $@ is a predefined variable which stands for the current target, hello in this case



$(CC) $(LDFLAGS) $(OBJECTS) -o $@





# generic rule for suffixes





# the dependency suffix goes before the target suffix



.cpp.o:

$(CC) $(CFLAGS) $< -o $@





# $<





# another predefined variable evaluating to the components





# used to make the target





# .cpp here



I'll stop here although there are more like special targets, predefined variables and directives.

They'll be covered when I'm able to write a more sophisticated Makefile myself.

It's just exciting to know what's underlying and what options you may have.



